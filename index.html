<!DOCTYPE html>
<!--  MyPictures - A local viewer for your photography library  -->
<!--                                                            -->
<!--  First run the build.py file with the folder you want to   -->
<!--  use. Add the -t (--thumbs) flag to generate thumbnails    -->
<!--  to make the whole experience faster. It will create a     -->
<!--  _thumbnails/ foldr in the provided folder, please leave   -->
<!--  it there while using the HTML viewer. You can now open    -->
<!--  HTML file and drop the JSON the script created. You can   -->
<!--  now browse your local pictures! Have fun :)               -->
<!--                                                            -->
<!--  The goal of this file is to keep all style and script     -->
<!--  inside the HTML so only one file hold the viewer.         -->
<!--                                                            -->
<!--  Not generating thumbs with build.py script can cause the  -->
<!--  browser to either freeze or crash on folders that have    -->
<!--  a lot of pictures in it.                                  -->
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <title>MyPictures</title>
  <style>
    :root {
      --grid-size: 168px;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      font-family: sans-serif;
      font-size: 62.5%;
      height: 100%;
      margin: 0;
      width: 100%;
    }

    body {
      align-items: center;
      display: flex;
      font-size: 1.6rem;
      justify-content: center;
    }

    @keyframes rotatePlane {
      0% {
        transform: perspective(120px) rotateX(0deg) rotateY(0deg);
      } 50% {
        transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg);
      } 100% {
        transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
      }
    }

    .library-new,
    .library-view {
      align-items: center;
      display: flex;
      flex-direction: column;
      height: 80%;
      justify-content: center;
      width: 80%;
    }

    .dnd-container {
      background-color: rgba(100, 100, 255, 0.05);
      border: solid 3px rgba(127, 127, 127, 0.15);
      border-radius: 5px;
      height: 50%;
      width: 70%;
    }

    .dnd-container::before {
      content: 'Drag a JSON report file in here...';
      display: block;
      font-size: 1.6rem;
      font-style: italic;
      height: auto;
      text-align: center;
      transform: translateY(50%);
      width: 100%;
    }

    .library-view {
      display: none;
      flex-direction: row;
      height: 100%;
      width: 100%;
    }

    .tree-list-container {
      height: 100%;
      overflow: auto;
      width: 280px;
    }

    .scene {
      border-left: solid 1px grey;
      height: 100%;
      overflow: auto;
      width: calc(100% - 280px);
    }

    .controls {
      align-items: center;
      border-bottom: solid 1px grey;
      display: flex;
      height: 3rem;
      justify-content: space-between;
    }

    .controls h3 {
      margin: 0;
      padding-left: 15px;
    }

    .controls h3 span {
      cursor: pointer;
    }

    .controls h3 span::after {
      content: '>';
      padding: 0 7.5px;
    }

    .controls h3 span:last-child::after {
      content: '';
      padding: 0;
    }

    .slider-wrapper {
      align-items: center;
      height: 3rem;
      display: flex;
      justify-content: center;
      width: max-content;
    }

    .slider-wrapper svg {
      cursor: pointer;
      height: 2rem;
      padding: 0 5px;
      width: calc(2rem + 10px);
    }

    .slide-zoom {
      display: flex;
      height: 3rem;
    }

    .browser {
      align-items: stretch;
      display: grid;
      gap: 1rem;
      height: calc(100% - 3rem - 2rem);
      justify-items: stretch;
      grid-template-columns: repeat(auto-fit, var(--grid-size));
      grid-template-rows: repeat(auto-fit, calc(var(--grid-size) + 1.2rem));
      padding: 15px;
      overflow: auto;
    }

    .browser div {
      align-items: center;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      max-height: calc(var(--grid-size) + 1.2rem);
      max-width: var(--grid-size);
      object-fit: cover;
      object-position: center;
    }

    .browser div p {
      font-size: 1.2rem;
    }

    .browser div svg {
      max-width: var(--grid-size);
      max-height: var(--grid-size);
    }

    .browser div img,
    .browser div video {
      max-width: var(--grid-size);
      max-height: var(--grid-size);
      object-fit: cover;
      object-position: center;
    }

    .status-bar {
      align-items: center;
      border-top: solid 1px grey;
      display: flex;
      height: 2rem;
      justify-content: space-between;
      width: 100%;
    }

    .status-bar p {
      font-size: 1.2rem;
      margin: 0;
      padding: 0 5px;
    }

    .slideshow {
      background-color: rgba(0, 0, 0, 0.95);
      display: none;
      height: 100vh;
      left: 0;
      position: absolute;
      top: 0;
      width: 100vw;
    }

    .slideshow-close {
      cursor: pointer;
      position: absolute;
      right: 5px;
      top: 5px;
      color: white;
    }

    .slideshow-viewer {
      align-items: center;
      display: flex;
      height: calc(100% - 10rem);
      justify-content: center;
      overflow: hidden;
      padding: 15px;
      width: 100%;
    }

    .slideshow-viewer::before {
      content: '';
      background-color: rgb(55, 195, 64);
      border-radius: 5px;
      height: 35px;
      left: calc(50% - (35 / 2)));
      position: absolute;
      top: 50%;
      width: 35px;
      z-index: 100;
      animation: rotatePlane 1.2s infinite ease-in-out;
    }

    .slideshow-viewer img {
      max-height: 100%;
      z-index: 101;
    }

    .slideshow-controls {
      background-color: black;
      border-top: solid 1px grey;
      display: flex;
      height: 10rem;
      overflow: auto;
      scroll-behavior: smooth;
      width: 100%;
    }

    .slideshow-controls img {
      cursor: pointer;
      height: 100%;
      padding: 5px;
    }

    .slideshow-controls img.selected {
      background-color: red;
    }

    .slideshow-previous,
    .slideshow-next {
      cursor: pointer;
      height: 2rem;
      position: absolute;
      top: calc((100% - 10rem) / 2);
      width: 2rem;
    }
    .slideshow-previous svg,
    .slideshow-next svg {
      fill: white;
    }
    .slideshow-previous {
      left: 0;
    }
    .slideshow-next {
      right: 0;
    }
    /* TreeList css */
    .tree-list{box-sizing:border-box;font-family:Helvetica, sans-serif;font-size:14px;line-height:19.6px;margin:0;padding:5px}.tree-list .tree-list-node{box-sizing:border-box;clear:both;cursor:pointer;display:inline-block;float:left;position:relative}.tree-list .tree-list-node .vector{height:15px;left:2px;margin:0;position:absolute;top:2px;width:15px}.tree-list .tree-list-node .vector svg{height:15px;transform:scale(0.8);width:15px}.tree-list .tree-list-node p{background:rgba(0,0,0,0.1);border-radius:2px;clear:both;font-size:.85em;float:left;line-height:20px;margin:0;margin-bottom:3px;margin-left:20px;max-width:100%;padding:0 5px;white-space:nowrap}.tree-list .tree-list-node p:hover{color:red}.tree-list .tree-list-node .tree-list-node.tree-list-node{margin-left:15px;width:auto}
  </style>
</head>
<body>
  <div class="library-new">
    <h1>MyPictures</h1>
    <div class="dnd-container"></div>
  </div>
  <div class="library-view">
    <div class="tree-list-container"></div>
    <div class="scene">
      <div class="controls">
        <h3 class="view-title"></h3>
        <div class="slider-wrapper">
          <svg id="grid-size-less" data-type="less" enable-background="new 0 0 512 512" version="1.1" viewBox="0 0 512 512" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
        		<path data-type="less" d="m506.14 477.85-144.45-144.45c65.813-80.075 61.335-198.94-13.451-273.73h-1e-3c-79.558-79.559-209.01-79.558-288.57 0-79.559 79.559-79.559 209.01 0 288.57 74.766 74.766 193.62 79.293 273.73 13.451l144.45 144.45c7.814 7.813 20.478 7.811 28.29 0 7.811-7.812 7.811-20.478 0-28.29zm-186.19-157.9c-63.959 63.96-168.03 63.959-231.99 0-63.96-63.96-63.96-168.03 0-231.99 63.958-63.958 168.03-63.961 231.99 0 63.96 63.96 63.96 168.03 0 231.99z"/>
        		<path data-type="less" d="m301.9 183.95h-195.89c-11.048 0-20.004 8.956-20.004 20.004s8.956 20.004 20.004 20.004h195.89c11.048 0 20.004-8.956 20.004-20.004s-8.956-20.004-20.004-20.004z"/>
          </svg>
          <div class="slide-zoom">
            <input type="range" min="0" max="6" value="3" class="slider" id="myRange">
          </div>
          <svg id="grid-size-more" data-type="more" enable-background="new 0 0 512 512" version="1.1" viewBox="0 0 512 512" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
          	<path data-type="more" d="m506.14 477.85-144.45-144.45c65.814-80.075 61.336-198.94-13.451-273.73-79.559-79.559-209.01-79.559-288.57 0s-79.559 209.01 0 288.57c74.766 74.766 193.62 79.293 273.73 13.451l144.45 144.45c7.812 7.812 20.477 7.812 28.289 0 7.813-7.813 7.813-20.478 1e-3 -28.29zm-186.19-157.9c-63.96 63.96-168.03 63.959-231.99 0-63.96-63.96-63.96-168.03 0-231.99 63.958-63.957 168.03-63.962 231.99 0 63.96 63.96 63.96 168.03 0 231.99z"/>
          	<path data-type="more" d="m301.9 183.95h-77.94v-77.94c0-11.048-8.956-20.004-20.004-20.004s-20.004 8.956-20.004 20.004v77.94h-77.94c-11.048 0-20.004 8.956-20.004 20.004s8.956 20.004 20.004 20.004h77.94v77.94c0 11.048 8.956 20.004 20.004 20.004s20.004-8.956 20.004-20.004v-77.94h77.94c11.048 0 20.004-8.956 20.004-20.004s-8.956-20.004-20.004-20.004z"/>
          </svg>
        </div>
      </div>
      <div class="browser"></div>
      <div class="status-bar">
        <p class="folder-status-info">Testing</p>
        <p class="image-status-info"></p>
      </div>
    </div>
  </div>
  <div class="slideshow">
    <div class="slideshow-close">✖</div>
    <div class="slideshow-previous">
      <svg enable-background="new 0 0 512 512" version="1.1" viewBox="0 0 512 512" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
    		<path d="m379.64 477.87-207.3-207.73c-7.798-7.798-7.798-20.486 0.015-28.299l207.28-207.72c7.803-7.819 7.789-20.482-0.029-28.284-7.819-7.803-20.482-7.79-28.284 0.029l-207.27 207.7c-23.394 23.394-23.394 61.459-0.015 84.838l207.28 207.72c3.907 3.915 9.031 5.873 14.157 5.873 5.111 0 10.224-1.948 14.128-5.844 7.818-7.802 7.831-20.465 0.029-28.284z"/>
      </svg>
    </div>
    <div class="slideshow-viewer"></div>
    <div class="slideshow-next">
      <svg enable-background="new 0 0 512 512" version="1.1" viewBox="0 0 512 512" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
    		<path d="m132.34 477.87 207.3-207.73c7.798-7.798 7.798-20.486-0.015-28.299l-207.28-207.72c-7.803-7.819-7.789-20.482 0.029-28.284 7.819-7.803 20.482-7.79 28.284 0.029l207.27 207.7c23.394 23.394 23.394 61.459 0.015 84.838l-207.28 207.72c-3.907 3.915-9.031 5.873-14.157 5.873-5.111 0-10.224-1.948-14.128-5.844-7.818-7.802-7.831-20.465-0.029-28.284z"/>
      </svg>
    </div>
    <div class="slideshow-controls"></div>
  </div>
  <!-- Icons from flaticon ! Display none to only store them (and clone them in script when needed) -->
  <svg id="folder-icon" style="display:none" enable-background="new 0 0 468.293 468.293" version="1.1" viewBox="0 0 468.29 468.29" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
    <path d="m29.525 50.447h112c7.335 0 14.11 3.918 17.77 10.274l18.433 25.181c3.66 6.356 10.436 10.274 17.77 10.274h272.8v287.5c0 15.099-12.241 27.34-27.34 27.34h-413.61c-15.099 0-27.34-12.241-27.34-27.34v-255.6c0-21.133 3.265-42.14 9.68-62.276 2.35-9.037 10.508-15.345 19.845-15.345z" fill="#F6C358"/>
    <rect x="42.615" y="91.473" width="359.96" height="152.06" fill="#EBF0F3"/>
    <path d="m447.79 64.117h-112.86c-8.026 0-15.315 4.683-18.65 11.983l-19.313 42.267c-3.336 7.3-10.624 11.983-18.65 11.983h-278.31v260.16c0 15.099 12.241 27.34 27.34 27.34h413.61c15.099 0 27.34-12.241 27.34-27.34v-305.88c0-11.324-9.181-20.505-20.505-20.505z" fill="#FCD462"/>
  </svg>
</body>
<script type="module">
'use strict';
/* TreeList Js */
class TreeListNode {
	constructor(options = {}) {
    // Prevent wrong type for arguments, fallback according to attribute utility
    if (typeof options.id !== 'number') {
      options.id = -1;
    }
    if (typeof options.name !== 'string') {
      options.name = 'Invalid model item';
    }
    if (typeof options.depth !== 'number') {
      options.depth = -1;
    }
    if (typeof options.clicked !== 'function') {
      options.clicked = undefined;
    }
		this._id = options.id;
		this._name = options.name;
		this._depth = options.depth;
		this._clicked = options.clicked;
		this._isLeaf = false;
		this._isExpanded = false;
    this._data = options.data;
		this._children = [];
		this._dom = {
			container: null,
			label: null,
			expander: null,
			icon: null,
			iconPath: null
		};
		// Collapse/Expand svg pathes
    /** @private
     * @member {object} - Expand/Collapse icon svg pathes */
		this._svgPath = {
			expand: 'M 15.000348,6.2497966 H 8.7502034 V -3.4865e-4 H 6.2501452 V 6.2497966 H 0 V 8.7498548 H 6.2501452 V 15 H 8.7502034 V 8.7498548 h 6.2501446 z',
			collapse: 'M 0,6.2493128 H 15.004124 V 8.7506872 H -0.0041235 z'
		};
		// Event binding for proper remove listener on destroy node
		this._onNodeClick = this._onNodeClick.bind(this);
		this._onNodeToggle = this._onNodeToggle.bind(this);
		// Build the node DOM with its internal info
		this._buildUI();
	}

	destroy() {
		// Call destroy method on each child node
		for (let i = 0; i < this._children.length; ++i) {
			this._children[i].destroy();
		}
		// Remove click listener
		this._dom.label.removeEventListener('click', this._onNodeClick, false);
		// On node toggle is only listened if node is expandable/collapsable
		if (!this._isLeaf) {
			this._dom.expander.removeEventListener('click', this._onNodeToggle, false);
		}
    // Delete object attributes
    Object.keys(this).forEach(key => {
      delete this[key];
    });
	}

	_buildUI() {
		// Create node DOM elements
		this._dom.container = document.createElement('DIV');
		this._dom.label = document.createElement('P');
		// Update node DOM internal attributes
		this._dom.container.classList.add('tree-list-node');
		this._dom.container.dataset.id = this._id;
		this._dom.label.innerHTML = this._name;
		// React to event and append to DOM
		this._dom.label.addEventListener('click', this._onNodeClick, false);
		this._dom.container.appendChild(this._dom.label);
	}

	_onNodeClick() {
		// Only fire callback if one has been provided
		if (typeof this._clicked === 'function') {
			this._clicked({
				id: this._id,
				name: this._name,
				depth: this._depth,
				isLeaf: this._isLeaf,
				isExpanded: this._isExpanded,
        data: this._data
			});
		}
	}

	_onNodeToggle() {
		// Only toggle if node has children
		if (this._children.length > 0) {
			if (this._isExpanded) { // Collapse node
				this.collapse(false);
			} else { // Expand node
				this.expand(false);
			}
		}
	}

	setExpander() {
		if (this._children.length === 0) { // No children, no expander
			this._isLeaf = true;
		} else { // Create expander for node
			// Icon DOM elements
			this._dom.expander = document.createElement('DIV');
			this._dom.icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			this._dom.iconPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
			// Update icon elements attributes
			this._dom.expander.classList.add('vector');
			this._dom.iconPath.setAttribute('d', this._svgPath.expand);
    	this._dom.iconPath.setAttribute('fill', '#000000');
    	// react to toggle event and append icon elements to the node container
			this._dom.expander.addEventListener('click', this._onNodeToggle, false);
  		this._dom.icon.appendChild(this._dom.iconPath);
  		this._dom.expander.appendChild(this._dom.icon);
			this._dom.container.insertBefore(this._dom.expander, this._dom.container.firstChild); // Insert before to put it first
		}
	}

	expand(recursive = false) {
		if (this._children.length > 0) {
			this._dom.iconPath.setAttribute('d', this._svgPath.collapse);
			// Append children into node container
			for (let i = 0; i < this._children.length; ++i) {
				// Call expand on children and pass recursive flag
				if (recursive) {
					this._children[i].expand(recursive);
				}
				// Append child from DOM container
				this._dom.container.appendChild(this._children[i].container);
			}
			// Update expand flag
			this._isExpanded = true;
		}
	}

	collapse(recursive = false) {
		if (this._children.length > 0) {
			this._dom.iconPath.setAttribute('d', this._svgPath.expand);
			// Remove children from node container
			for (let i = 0; i < this._children.length; ++i) {
				// Call collapse on children and pass recursive flag
				if (recursive) {
					this._children[i].collapse(recursive);
				}
				// Remove child from DOM container
				this._dom.container.removeChild(this._children[i].container);
			}
			// Update expand flag
			this._isExpanded = false;
		}
	}

  expandNode(id) {
    for (let i = 0; i < this._children.length; ++i) {
      if (this._children[i]._id === id) {
        this._children[i].expand();
      } else {
        this._children[i].expandNode(id);
      }
    }
  }

  collapseNode(id) {
    for (let i = 0; i < this._children.length; ++i) {
      if (this._children[i]._id === id) {
        this._children[i].collapse();
      } else {
        this._children[i].collapseNode(id);
      }
    }
  }

	expandAll() {
		this.expand(true);
	}

	collapseAll() {
		this.collapse(true);
	}

	get children() { return this._children; }
	get container() { return this._dom.container; }
};
class TreeList {
  constructor(options = {}) {
    // Prevent wrong type for arguments, fallback according to attribute utility
    if (typeof options.renderTo !== 'object' || (options.renderTo && !options.renderTo.appendChild)) {
      options.renderTo = document.body;
    }
    if (typeof options.model !== 'object') {
      options.model = [];
    }
    if (typeof options.nodeClicked !== 'function') {
      options.nodeClicked = undefined;
    }
   	this._nodes = [];
   	this._container = options.renderTo;
    this._nodeClicked = options.nodeClicked;
    // Build model (ie build hierarchical nodes) and build ui DOM elements
   	this._buildModel(options.model);
   	this._buildUI();
  }

  destroy() {
    // Destroy model children, they will recursively destroy any existing nodes and listeners
    for (let i = 0; i < this._nodes.length; ++i) {
      this._nodes[i].destroy();
    }
    // Delete object attributes
    Object.keys(this).forEach(key => {
      delete this[key];
    });
  }

	_buildModel(model) {
		for (let i = 0; i < model.length; ++i) {
			this._nodes.push(this._buildNode(model[i], 0));
		}
	}

  _buildNode(nodeModel, depth) {
    // No need to pass children since we need full model generation before assigning descendants
    const node = new TreeListNode({
      id: nodeModel.id,
      name: nodeModel.name,
      depth: depth,
      clicked: this._nodeClicked,
      data: nodeModel
    });
    // Construct child node if any
    if (nodeModel.children && nodeModel.children.length > 0) {
      for (let i = 0; i < nodeModel.children.length; ++i) {
        node.children.push(this._buildNode(nodeModel.children[i], depth + 1));
      }
    }
    // Set expander only when children have been recursively constructed
    node.setExpander();
    return node;
  }

	_buildUI() {
		this._container.classList.add('tree-list');

		for (let i = 0; i < this._nodes.length; ++i) {
			this._container.appendChild(this._nodes[i].container);
		}
	}

  expandNode(id) {
    for (let i = 0; i < this._nodes.length; ++i) {
      if (this._nodes[i]._id === id) {
        this._nodes[i].expand();
      } else {
        this._nodes[i].expandNode(id);
      }
    }
  }


  collapseNode(id) {
    for (let i = 0; i < this._nodes.length; ++i) {
      if (this._nodes[i]._id === id) {
        this._nodes[i].collapse();
      } else {
        this._nodes[i].collapseNode(id);
      }
    }
  }

  expandAll() {
    for (let i = 0; i < this._nodes.length; ++i) {
      this._nodes[i].expand(true);
    }
  }

  collapseAll() {
    for (let i = 0; i < this._nodes.length; ++i) {
      this._nodes[i].collapse(true);
    }
  }
};
/* DnD class */
class DnD {
  constructor(options) {
    try {
      this._container = document.querySelector(options.target); // Get given target from the DOM
      this._onDropFileCB = options.onDropFile; // Assign the onDropFile callback to an internal
      this._events(); // Attach all drag events
    } catch(error) { // Mostly handle the case in which the target selector given as an argument is wrong
      console.error(`Unable to build the DnD class.\n${error}`);
    }
  }

  static formatAsJSON(raw) {
    return JSON.parse(raw);
  }

  _events() {
    this._container.addEventListener('dragenter', this._dragEnter.bind(this), false);
    this._container.addEventListener('dragover', this._dragOver.bind(this), false);
    this._container.addEventListener('dragleave', this._dragLeave.bind(this), false);
    this._container.addEventListener('drop', this._drop.bind(this), false);
  }

  _eventBehavior(event) {
    event.stopPropagation();
    event.preventDefault();
  }

  _dragEnter(event) {
    this._eventBehavior(event);
    this._container.style.border = 'dashed 3px rgb(255, 100, 100)';
  }

  _dragOver(event) {
    this._eventBehavior(event);
    event.dataTransfer.dropEffect = 'copy';
  }

  _dragLeave(event) {
    this._eventBehavior(event);
    this._container.style.border = this._borderStyle;
  }

  _drop(event) {
    this._eventBehavior(event);
    this._container.style.border = this._borderStyle;

    const files = event.dataTransfer.files;
    for (let i = 0, file; file = files[i]; ++i) {
      const reader = new FileReader();
      reader.onload = (theFile => {
        return raw => {
          this._onDropFileCB(files[i], raw);
        };
      })(file);
      reader.readAsText(file);
    }
  }
}
/* Keyboard shortcut class */
class Shortcut {
  constructor(options = {}) {
    // If an instance of Shortcut already exists, we just return it
    if (!!Shortcut.instance) {
      return Shortcut.instance;
    }
    // Set object instance
    Shortcut.instance = this;
    // Prevent wrong type for arguments, fallback according to attribute utility
    if (typeof options.keyEvent !== 'string' || (['keydown', 'keyup', 'keypress'].indexOf(options.keyEvent) === -1)) {
      options.keyEvent = 'keydown';
    }
    if (typeof options.autoRepeat !== 'boolean') {
      options.autoRepeat = true;
    }
    this._keyEvent = options.keyEvent;
    this._autoRepeat = options.autoRepeat;
    this._singleKey = [];
    this._multiKey = [];
    this.version = '1.0.0';
    // Save singleton scope for testShortcuts method to be able to properly remove event on demand
    this._testShortcuts = this._testShortcuts.bind(this);
    // Retun singleton to the caller
    return this;
  }

  destroy() {
    // Remove all existing eventListener
    this._removeEvents();
    // Delete object attributes
    Object.keys(this).forEach(key => {
      delete this[key];
    });
    // Clear singleton instance
    Shortcut.instance = null;
  }

  _addEvents() {
    // Listen to keyboard's event
    document.addEventListener(this._keyEvent, this._testShortcuts);
  }

  _removeEvents() {
    // Revoke listener on keyboard's event
    document.removeEventListener(this._keyEvent, this._testShortcuts);
  }

  _testShortcuts(event) {
    // Avoid auto repeat event if singleton is configured this way
    if (this._autoRepeat === false && event.repeat === true) {
      event.preventDefault();
      return;
    }

    // Analyze event to check proper shortcut array
    if (event.ctrlKey || event.altKey || event.shiftKey) { // Multi key shortcut
      this._multiKeyEvent(event);
    } else { // Single key shortcut
      this._singleKeyEvent(event);
    }
  }

  _singleKeyEvent(event) {
    // Iterate over registered single key shortcut to fire it if one matches
    for (let i = 0; i < this._singleKey.length; ++i) {
      // Check that event is active and flatten key string to compare
      if (!this._singleKey[i].pause && event.key.toLowerCase() === this._singleKey[i].key) {
        event.preventDefault();
        this._singleKey[i].fire(this);
      }
    }
  }

  _multiKeyEvent(event) {
    for (let i = 0; i < this._multiKey.length; ++i) {
      // Handy shortcut variable to work with
      const sh = this._multiKey[i];
      // Check that event is active and flatten key string to compare
      if (!sh.pause && event.key.toLowerCase() === sh.key) {
        switch (sh.modifierCount) {
          case 1: // 2 key strokes
            if ((sh.modifiers.ctrlKey && event.ctrlKey)
            || (sh.modifiers.altKey && event.altKey)
            || (sh.modifiers.shiftKey && event.shiftKey)) {
              event.preventDefault();
              sh.fire();
            }
            break;
          case 2: // 3 key strokes
            if ((sh.modifiers.ctrlKey && event.ctrlKey && sh.modifiers.altKey && event.altKey)
            || (sh.modifiers.ctrlKey && event.ctrlKey && sh.modifiers.shiftKey && event.shiftKey)
            || (sh.modifiers.altKey && event.altKey && sh.modifiers.shiftKey && event.shiftKey)) {
              event.preventDefault();
              sh.fire();
            }
            break;
          case 3: // 4 key strokes
            if ((sh.modifiers.ctrlKey && event.ctrlKey
            && sh.modifiers.altKey && event.altKey
            && sh.modifiers.shiftKey && event.shiftKey)) {
              event.preventDefault();
              sh.fire();
            }
            break;
          default:
            break;
        }
      }
    }
  }

  _getModifiersCount(keyString) {
    // Build local modifiers count with regex
    const modifiers = {
      ctrlKey: /ctrl/i.test(keyString),
      altKey: /alt/i.test(keyString),
      shiftKey: /shift/i.test(keyString)
    };
    // Count modifiers that are set to true and update count with it
    let count = 0;
    Object.values(modifiers).reduce((a, item) => count = a + item, 0);
    // Return count value
    return count;
  }

  _setAllPauseFlag(value) {
    // Iterate over both arays to update pause flag on each registered shortcut
    for (let i = 0; i < this._singleKey.length; ++i) {
      this._setOnePauseFlag(this._singleKey[i].keyString, value);
    }

    for (let i = 0; i < this._multiKey.length; ++i) {
      this._setOnePauseFlag(this._multiKey[i].keyString, value);
    }
  }

  _setOnePauseFlag(keyString, value) {
    if (this._getModifiersCount(keyString) === 0) {
      for (let i = 0; i < this._singleKey.length; ++i) {
        if (this._singleKey[i].keyString === keyString) {
          this._singleKey[i].pause = value;
        }
      }
    } else {
      for (let i = 0; i < this._multiKey.length; ++i) {
        if (this._multiKey[i].keyString === keyString) {
          this._multiKey[i].pause = value;
        }
      }
    }
  }

  _shortcutAlreadyExist(keyString) {
    // Parse single or multi shortcuts depending on modifiers count to find maching one
    if (this._getModifiersCount(keyString) === 0) {
      for (let i = 0; i < this._singleKey.length; ++i) {
        if (this._singleKey[i].keyString === keyString) {
          return true;
        }
      }
    } else {
      for (let i = 0; i < this._multiKey.length; ++i) {
        if (this._multiKey[i].keyString === keyString) {
          return true;
        }
      }
    }
    // False by default to allow the shortcut creation
    return false;
  }

  register(keyString, fire) {
    if (typeof keyString !== 'string' || typeof fire !== 'function') {
      return;
    }

    if (!this._shortcutAlreadyExist(keyString)) {
      // First shortcut to be registered ; listen to keyboard key down event
      if (this._singleKey.length === 0 && this._multiKey.length === 0) {
        this._addEvents();
      }
      // New shortcut internals
      const shortcut = {
        keyString: keyString,
        modifiers: { // Regex insensitive to string case to search for modifiers
          ctrlKey: /ctrl/i.test(keyString),
          altKey: /alt/i.test(keyString),
          shiftKey: /shift/i.test(keyString)
        },
        modifierCount: this._getModifiersCount(keyString),
        key: keyString.toLowerCase().replace('ctrl', '').replace('alt', '').replace('maj', '').replace(' ', ''),
        paused: false,
        fire: fire
      };
      // Save shortcut to its appropriated array
      if (this._getModifiersCount(keyString) === 0) {
        this._singleKey.push(shortcut);
      } else {
        this._multiKey.push(shortcut);
      }
    }
  }

  remove(keyString) {
    if (typeof keyString !== 'string') {
      return;
    }
    // Reverse parsing to ensure proper slicing of shortcut arrays
    if (this._getModifiersCount(keyString) === 0) {
      for (let i = this._singleKey.length - 1; i >= 0; i--) {
        if (this._singleKey[i].keyString === keyString) {
          this._singleKey.splice(i, 1);
        }
      }
    } else {
      for (let i = this._multiKey.length - 1; i >= 0; i--) {
        if (this._multiKey[i].keyString === keyString) {
          this._multiKey.splice(i, 1);
        }
      }
    }
    // In case there are no remaining shortcut, we remove listener on keyboard's event
    if (this._singleKey.length === 0 && this._multiKey.length === 0) {
      this._removeEvents();
    }
  }

  removeAll() {
    // Clear all saved shortcut
    this._singleKey = [];
    this._multiKey = [];
    // Remove listener on keyboard's key down
    this._removeEvents();
  }

  pause(keyString) {
    if (typeof keyString !== 'string') {
      return;
    }

    this._setOnePauseFlag(keyString, true);
  }

  resume(keyString) {
    if (typeof keyString !== 'string') {
      return;
    }

    this._setOnePauseFlag(keyString, false);
  }

  pauseAll() {
    this._setAllPauseFlag(true);
  }

  resumeAll() {
    this._setAllPauseFlag(false);
  }

  updateKeyEvent(keyEvent) {
    // Prevent wrong type or un-existing key event
    if (typeof keyEvent !== 'string' || (['keydown', 'keyup', 'keypress'].indexOf(keyEvent) === -1)) {
      keyEvent = 'keydown';
    }
    // Key event actual update
    this._removeEvents(); // Remove previous key event value and shortcut listener
    this._keyEvent = keyEvent; // Update private attribute
    this._addEvents(); // Restore shortcut listening with knew key event
  }

  updateAutoRepeat(autoRepeat) {
    // Prevent wrong type for input
    if (typeof autoRepeat !== 'boolean') {
      autoRepeat = true;
    }
    // Update private attribute
    this._autoRepeat = autoRepeat;
  }
}
/* App handling */
const keyboard = new Shortcut();
let basePath = './';
let globalModel = null;
let myTreeList = {};
const DnDController = new DnD({
  target: '.dnd-container',
  onDropFile: (fileInfo, data) => {
    if (fileInfo.type === 'application/json') {
      loadJSON(fileInfo, DnD.formatAsJSON(data.target.result));
    } else {
      console.error('failure', 'Dropped file is not a JSON');
    }
  }
});
const loadJSON = (fileInfo, data) => {
  document.querySelector('.library-new').style.display = 'none';
  document.querySelector('.library-view').style.display = 'flex';
  basePath = data[Object.keys(data)[0]].path;
  globalModel = data[Object.keys(data)[0]];
  myTreeList = new TreeList({
    renderTo: document.querySelector('.tree-list-container'),
    model: data[Object.keys(data)[0]].children,
    nodeClicked: node => {
      switchView(node.data);
    },
  });
  switchView(data[Object.keys(data)[0]]);
};
const findInModel = (name, model) => {
  if (model.name === name) {
    return model;
  } else if (model.children && model.children.length !== 0) {
      let result = null;
      for (let i = 0; result == null && i < model.children.length; ++i) {
         result = findInModel(name, model.children[i]);
      }
      return result;
   }
   return null;
};
const buildPath = (data) => {
  document.querySelector('.view-title').innerHTML = '';
  let path  = data.path.split('\\');
  if (path.length === 0) {
    path = data.path.split('/');
  }
  let index = 0;
  for (let i = path.length; i > 0; --i) {
    if (path[i] === globalModel.name) {
      index = i;
      break;
    }
  } // Iterate from found index to path array end and hadle each path
  for (let i = index; i < path.length; ++i) {
    const element = document.createElement('SPAN');
    element.addEventListener('click', () => {
      switchView(findInModel(path[i], globalModel));
    }, false);
    element.innerHTML = path[i];
    document.querySelector('.view-title').appendChild(element);
  }
};
const buildStatus = (data, element = {}) => {
  document.querySelector('.folder-status-info').innerHTML = `${data.children.length} elements`;
  document.querySelector('.image-status-info').innerHTML = ``;
  if (element.exif) {
    const focal = element.exif.FocalLength || '';
    const exposure = element.exif.ExposureTime || '';
    const fNumber = element.exif.FNumber || '';
    const iso = element.exif.ISOSpeedRatings || '';
    const manufacturer = element.exif.Make || '';
    const model = element.exif.Model || '';
    const lense = element.exif.LensModel || '';
    document.querySelector('.image-status-info').innerHTML = `${manufacturer}${manufacturer ?' - ':''}${model}${model ?' - ':''}${lense}${lense ?' - ':''}${focal}${focal ?'mm - ':''}${exposure}${exposure ?'s - ':''}${fNumber ?'f':''}${fNumber}${fNumber?' - ':''}${iso}${iso ?' ISO':''}`;
    return;
  }
};
const switchView = data => {
  document.querySelector('.browser').innerHTML = '';
  buildPath(data);
  buildStatus(data);
  data.children.sort((a, b) => {
    return a.type > b.type;
  });
  requestAnimationFrame(() => {
    for (let i = 0; i < data.children.length; ++i) {
      if (data.children[i].type === 'directory') { // Build a folder in UI
        myTreeList.expandNode(data.id);
        const folder = document.createElement('DIV');
        const icon = document.querySelector('#folder-icon').cloneNode(true);
        const label = document.createElement('P');
        label.innerHTML = data.children[i].name;
        icon.style.display = 'block';
        folder.appendChild(icon);
        folder.appendChild(label);
        document.querySelector('.browser').appendChild(folder);
        folder.addEventListener('click', () => {
          switchView(data.children[i]);
        }, false);
      } else if (data.children[i].type === 'image') { // Build a file in UI
        const file = document.createElement('DIV');
        const img = document.createElement('IMG');
        const label = document.createElement('P');
        label.innerHTML = data.children[i].name;
        img.loading = 'lazy'; // Specify lazy loading for browser to load album faster
        file.appendChild(img);
        file.appendChild(label);
        document.querySelector('.browser').appendChild(file);
        // Setting image source (either thumbnail or real size)
        loadImage(img, `file://${basePath}/_thumbnails/${data.children[i].id}.jpg`, `file://${data.children[i].path}`);
        file.addEventListener('click', () => {
          slideShow(data, data.children[i]);
        }, false);

        file.addEventListener('mouseenter', () => {
          buildStatus(data, data.children[i]);
        }, false);
        file.addEventListener('mouseleave', () => {
          buildStatus(data);
        }, false);
      } else if (data.children[i].type === 'video') { // Build a file in UI
        const file = document.createElement('DIV');
        const label = document.createElement('P');
        const vid = document.createElement('VIDEO');
        label.innerHTML = data.children[i].name;
        vid.setAttribute('controls', 'here');
        vid.src = `file://${data.children[i].path}`;
        vid.load();
        file.appendChild(vid);
        file.appendChild(label);
        document.querySelector('.browser').appendChild(file);
      }
    }
  });
};
const loadImage = (img, thumb, full) => {
  requestAnimationFrame(() => {
    fetch(thumb, { method: 'HEAD' }).then(res => {
      if (res.ok) { // Load Thumbnail
        img.src = thumb;
      } else { // Fallback on full sized image
        img.src = full;
      }
    }).catch(err => {
       img.src = full;
    });
  });
};
const slideShow = (data, selected) => {
  const slideshowThumbs = [];
  document.querySelector('.slideshow').style.display = 'block';
  document.querySelector('.slideshow-viewer').innerHTML = '';
  document.querySelector('.slideshow-controls').innerHTML = '';
  const selectedImg = document.createElement('IMG');
  document.querySelector('.slideshow-viewer').appendChild(selectedImg);
  loadImage(selectedImg, `file://${selected.path}`, `file://${selected.path}`);
  for (let i = 0; i < data.children.length; ++i) {
    if (data.children[i].type === 'image') {
      const img = document.createElement('IMG');
      img.dataset.id = data.children[i].id;
      // Add selected class to
      document.querySelector('.slideshow-controls').appendChild(img);
      slideshowThumbs.push(img);
      // Setting image source (either thumbnail or real size)
      loadImage(img, `file://${basePath}/_thumbnails/${data.children[i].id}.jpg`, `file://${data.children[i].path}`);
      img.addEventListener('click', () => {
        document.querySelector('.slideshow-viewer').innerHTML = '';
        const newImg = document.createElement('IMG');
        for (let j = 0; j < slideshowThumbs.length; ++j) {
          if (parseInt(slideshowThumbs[j].dataset.id) === data.children[i].id) {
            selected.classList.remove('selected');
            slideshowThumbs[j].classList.add('selected');
            selected = slideshowThumbs[j];
            document.querySelector('.slideshow-controls').scrollLeft = selected.offsetLeft - (window.innerWidth / 2) + ((selected.width + 10) / 2); // +10px is for img paddings
            break;
          }
        }
        document.querySelector('.slideshow-viewer').appendChild(newImg);
        loadImage(newImg, `file://${data.children[i].path}`, `file://${data.children[i].path}`);
      }, false);
    }
  }
  // Now iterate through thumb elements to center on
  const nextImg = () => {
    for (let i = 0; i < slideshowThumbs.length; ++i) {
      if (slideshowThumbs[i].dataset.id === selected.dataset.id) {
        selected.classList.remove('selected');
        slideshowThumbs[(i + 1) % (slideshowThumbs.length)].classList.add('selected');
        selected = slideshowThumbs[(i + 1) % (slideshowThumbs.length)];
        document.querySelector('.slideshow-controls').scrollLeft = selected.offsetLeft - (window.innerWidth / 2) + ((selected.width + 10) / 2); // +10px is for img paddings
        break;
      }
    }
    for (let i = 0; i < data.children.length; ++i) {
      if (parseInt(selected.dataset.id) === data.children[i].id) {
        document.querySelector('.slideshow-viewer').innerHTML = '';
        const newImg = document.createElement('IMG');
        document.querySelector('.slideshow-viewer').appendChild(newImg);
        loadImage(newImg, `file://${data.children[i].path}`, `file://${data.children[i].path}`);
        break;
      }
    }
  };
  const prevImg = () => {
    for (let i = 0; i < slideshowThumbs.length; ++i) {
      if (slideshowThumbs[i].dataset.id === selected.dataset.id) {
        selected.classList.remove('selected');
        slideshowThumbs[(i - 1 + slideshowThumbs.length) % (slideshowThumbs.length)].classList.add('selected');
        selected = slideshowThumbs[(i - 1 + slideshowThumbs.length) % (slideshowThumbs.length)];
        document.querySelector('.slideshow-controls').scrollLeft = selected.offsetLeft - (window.innerWidth / 2) + ((selected.width + 10) / 2); // +10px is for img paddings
        break;
      }
    }
    for (let i = 0; i < data.children.length; ++i) {
      if (parseInt(selected.dataset.id) === data.children[i].id) {
        document.querySelector('.slideshow-viewer').innerHTML = '';
        const newImg = document.createElement('IMG');
        document.querySelector('.slideshow-viewer').appendChild(newImg);
        loadImage(newImg, `file://${data.children[i].path}`, `file://${data.children[i].path}`);
        break;
      }
    }
  };
  setTimeout(() => {
    for (let i = 0; i < slideshowThumbs.length; ++i) {
      if (parseInt(slideshowThumbs[i].dataset.id) === selected.id) {
        slideshowThumbs[i].classList.add('selected');
        selected = slideshowThumbs[i];
        document.querySelector('.slideshow-controls').scrollLeft = selected.offsetLeft - (window.innerWidth / 2) + ((selected.width + 10) / 2);
        break;
      }
    }
  }, slideshowThumbs.length);
  document.querySelector('.slideshow-controls').addEventListener('wheel', event => {
    if (!event.deltaY) { return; }
    event.currentTarget.style.scrollBehavior = 'inherit';
    event.currentTarget.scrollLeft += (event.deltaY * 30);
    event.currentTarget.style.scrollBehavior = 'smooth';
  }, false);
  document.querySelector('.slideshow-previous').addEventListener('click', prevImg, false);
  document.querySelector('.slideshow-next').addEventListener('click', nextImg, false);
  document.querySelector('.slideshow-close').addEventListener('click', () => {
    document.querySelector('.slideshow').style.display = 'none';
    document.querySelector('.slideshow-viewer').innerHTML = '';
    document.querySelector('.slideshow-controls').innerHTML = '';
    keyboard.remove('ArrowLeft');
    keyboard.remove('ArrowRight');
    return;
  });
  keyboard.register('ArrowLeft', prevImg);
  keyboard.register('ArrowRight', nextImg);
};
const allowedWidth = [123, 135, 150, 168, 190, 218, 256];
const updateZoom = event => {
  let width = 168;
  let appliedWidth = window.getComputedStyle(document.documentElement).getPropertyValue('--grid-size');
  appliedWidth = parseInt(appliedWidth.substring(0, appliedWidth.length - 2));
  const index = allowedWidth.indexOf(appliedWidth);
  if (event.target.dataset.type === 'less') {
    if (index > 0) {
      width = allowedWidth[index - 1]
      document.querySelector('.slide-zoom').firstElementChild.value = index - 1;
    } else {
      width = allowedWidth[0];
      document.querySelector('.slide-zoom').firstElementChild.value = parseInt(0);
    }
  } else if (event.target.dataset.type === 'more') {
    if (index < allowedWidth.length - 1) {
      width = allowedWidth[index + 1]
      document.querySelector('.slide-zoom').firstElementChild.value = parseInt(index + 1);
    } else {
      width = allowedWidth[allowedWidth.length - 1];
      document.querySelector('.slide-zoom').firstElementChild.value = parseInt(allowedWidth.length - 1);
    }
  } else { // Slider was moved
    width = allowedWidth[parseInt(event.target.value)];
  }
  document.documentElement.style.setProperty('--grid-size', `${width}px`);
};
document.querySelector('.slide-zoom').addEventListener('input', updateZoom, false);
document.querySelector('#grid-size-less').addEventListener('click', updateZoom, false);
document.querySelector('#grid-size-more').addEventListener('click', updateZoom, false);
</script>
</html>
